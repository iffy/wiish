import std/json
import std/logging
import std/os
import std/osproc
import std/sequtils
import std/strformat
import std/strutils
import std/tables
import std/times

import regex

import ./common
import wiish/doctor
import wiish/building/config
import wiish/building/buildutil

const BUILD_AS_LIB = true

proc csource_dir*(ctx: ref BuildContext, android_abi: string): string {.inline.}

proc replaceInFile*(filename: string, replacements: Table[string, string]) =
  ## Replace lines in a file with the given replacements
  var guts = filename.readFile()
  for pattern, replacement in replacements:
    guts = guts.replace(re(pattern), replacement)
  filename.writeFile(guts)

proc activityName*(ctx: ref BuildContext): string {.inline.} =
  ctx.config.get(AndroidConfig).java_package_name.split({'.'})[^1] & "Activity"

proc fullActivityName*(ctx: ref BuildContext): string {.inline.} =
  ## Return the java.style.activity.name of an app
  ctx.config.get(AndroidConfig).java_package_name & "." & ctx.activityName()

proc activityJavaPath*(ctx: ref BuildContext): string =
  ## Return the path to the Java Activity .java file
  ctx.build_dir / "app" / "src" / "main" / "java" / ctx.config.get(AndroidConfig).java_package_name.replace(".", "/") / ctx.activityName() & ".java"

proc parseNimBuildDeps(path: string): tuple[cfiles:seq[string], ipaths:seq[string]] =
  ## Parse the .json file generated by nim --compileOnly --genScript
  ## and return the external c files and -I paths
  let depsjson = path.readFile.parseJson
  var
    external_c_files: seq[string]
    external_i_paths: seq[string]
  for item in depsjson["compile"]:
    let src = item[0].getStr()
    external_c_files.add(src)

    let cmd = item[1].getStr()
    # TODO: yes, this is naive and won't work if there are spaces in path names
    let parts = cmd.split(" ")
    for segment in parts:
      if segment.startsWith("-I"):
        let ipath = segment[2..^1].normalizedPath.absolutePath
        if ipath notin external_i_paths:
          external_i_paths.add(ipath)
  return (external_c_files, external_i_paths)

proc nimBuildDepJson(ctx: ref BuildContext, abi: string): string =
  when BUILD_AS_LIB:
    ctx.csource_dir(abi) / "lib" & ctx.main_nim.extractFilename.changeFileExt(".json")
  else:
    ctx.csource_dir(abi) / ctx.main_nim.extractFilename.changeFileExt(".json")

proc getCFiles*(ctx: ref BuildContext): seq[string] =
  ## Get the list of C files and static libs to be compiled
  ctx.log "Listing c files ..."
  for arch in ctx.config.get(AndroidConfig).archs:
    let srcdir = ctx.csource_dir(arch.abi).normalizedPath
    ctx.log &"Using {srcdir} for c files ..."
    if srcdir.existsDir():
      for item in walkDir(srcdir):
        if item.kind == pcFile and (item.path.endsWith(".c") or item.path.endsWith(".a")):
          ctx.log "  " & item.path.extractFilename()
          result.add("$(TARGET_ARCH_ABI)"/(&"{item.path.extractFilename}"))
    # external c files
    let (cfiles, ipaths) = parseNimBuildDeps(ctx.nimBuildDepJson(arch.abi))
    for cfile in cfiles:
      var f = cfile.normalizedPath
      if f.parentDir.isRelativeTo(srcdir):
        # exclude files already included up above
        continue
      ctx.log "  " & f
      result.add f
    if result.len > 0:
      break

proc getIncludePaths*(ctx: ref BuildContext): seq[string] =
  ## Return the previously-generated
  for arch in ctx.config.get(AndroidConfig).archs:
    let (cfiles, ipaths) = parseNimBuildDeps(ctx.nimBuildDepJson(arch.abi))
    ctx.log &"Found {ipaths.len} -I paths ..."
    result.add ipaths
    if result.len > 0:
      break

proc runningDevices(): seq[string] {.inline.} = 
  ## List all currently running Android devices
  shoutput("adb", "devices").strip.splitLines[1..^1]

proc possibleDevices(): seq[string] =
  ## List all installed android devices
  let emulator_bin = findExe("emulator")
  return shoutput(emulator_bin, "-list-avds").strip.splitLines

proc apk_path(ctx: ref BuildContext): string {.inline.} =
  let searchdir = block:
    if ctx.releaseBuild:
      ctx.build_dir/"app"/"build"/"outputs"/"apk"/"release"
    else:
      ctx.build_dir/"app"/"build"/"outputs"/"apk"/"debug"
  for path in walkDirRec(searchdir):
    if path.endsWith(".apk") and "universal" in path:
      return path

proc all_signables(ctx: ref BuildContext): seq[string] =
  ## Return all things that can be signed
  for path in walkDirRec(ctx.build_dir/"app"/"build"/"outputs"):
    # if path.endsWith(".apk") or path.endsWith(".aab"):
    if path.endsWith(".aab"):
      result.add path

proc csource_dir*(ctx: ref BuildContext, android_abi: string): string {.inline.} =
  ctx.build_dir/"app"/"jni"/"src"/android_abi

proc ensureEnv*(varname: string): string =
  ## Retrieve an environment variable or fail trying
  result = getEnv(varname)
  if result == "":
    raise ValueError.newException(&"Expected a value for environment variable {varname}")

proc androidRunStep*(step: BuildStep, ctx: ref BuildContext) =
  ## Wiish Standard Android build
  case step
  of Setup:
    ctx.logStartStep
    ctx.build_dir = ctx.projectPath / ctx.config.outDir / "android" / "project" / ctx.config.get(AndroidConfig).java_package_name
    ctx.build_dir.parentdir.createDir()
    if ctx.build_dir.dirExists():
      ctx.log "Removing old build dir: ", ctx.build_dir
      ctx.build_dir.removeDir()
    ctx.nim_flags.add ctx.config.nimFlags
    ctx.nim_flags.add "-d:appJavaPackageName=" & ctx.config.get(AndroidConfig).java_package_name
    if ctx.releaseBuild:
      ctx.nim_flags.add "-d:release"
    ctx.log &"archs = {ctx.config.get(AndroidConfig).archs}"
    if ctx.config.get(AndroidConfig).version_code == 0:
      ctx.config.get(AndroidConfig).version_code = getTime().toUnix()
    ctx.log &"version_code = {ctx.config.get(AndroidConfig).version_code}"
  of Compile:
    ctx.logStartStep
    proc buildFor(android_abi:string, cpu:string) =
      let nimcachedir = ctx.csource_dir(android_abi)
      if nimcachedir.dirExists:
        nimcachedir.removeDir()
      var nimFlags:seq[string]
      nimFlags.add(@["nim", "c"])
      nimFlags.add(ctx.nim_flags)
      nimFlags.add(@[
        "--os:android",
        "-d:android",
        "-d:androidNDK",
        &"--cpu:{cpu}",
        "--noMain:on",
        "--gc:orc",
        "--header",
        "--threads:on",
        "--tlsEmulation:off",
        "--hints:off",
        "--compileOnly",
        "--genScript",
        &"-d:appJavaPackageName={ctx.config.get(AndroidConfig).java_package_name}",
        "--nimcache:" & nimcachedir,
        ctx.main_nim,
      ])
      if BUILD_AS_LIB:
        nimFlags.add("--app:lib")
      ctx.log nimFlags.join(" ")
      sh(nimFlags)

    # Android ABIs: https://developer.android.com/ndk/guides/android_mk#taa
    # nim --cpus: https://github.com/nim-lang/Nim/blob/devel/lib/system/platforms.nim#L14
    var abis: seq[string]
    for arch in ctx.config.get(AndroidConfig).archs:
      buildFor(arch.abi, arch.cpu)
      abis.add(arch.abi)
    let abilist = abis.mapIt("'" & it & "'").join(", ")
    replaceInFile(ctx.build_dir/"app"/"build.gradle", {
      "compileSdkVersion.*?\n": &"compileSdkVersion {ctx.config.get(AndroidConfig).target_sdk_version}\n",
      "minSdkVersion.*?\n": &"minSdkVersion {ctx.config.get(AndroidConfig).min_sdk_version}\n",
      "versionCode .*?\n": &"versionCode {ctx.config.get(AndroidConfig).version_code}\n",
      "targetSdkVersion.*?\n": &"targetSdkVersion {ctx.config.get(AndroidConfig).target_sdk_version}\n",
      "\"APP_PLATFORM=.*?\"": &"\"APP_PLATFORM=android-{ctx.config.get(AndroidConfig).min_sdk_version}\"",
      "abiFilters.*?\n": &"abiFilters {abilist}\n",
    }.toTable)
  of PreBuild:
    ctx.logStartStep
    ctx.log &"Creating icons ..."
    var iconSrcPath:string
    if ctx.config.iconPath == "":
      iconSrcPath = stdDatadir/"default.png"
    else:
      iconSrcPath = ctx.projectPath/ctx.config.iconPath
    iconSrcPath.resizePNG(ctx.build_dir/"app"/"src"/"main"/"res"/"mipmap-mdpi"/"ic_launcher.png", 48, 48)
    iconSrcPath.resizePNG(ctx.build_dir/"app"/"src"/"main"/"res"/"mipmap-hdpi"/"ic_launcher.png", 72, 72)
    iconSrcPath.resizePNG(ctx.build_dir/"app"/"src"/"main"/"res"/"mipmap-xhdpi"/"ic_launcher.png", 96, 96)
    iconSrcPath.resizePNG(ctx.build_dir/"app"/"src"/"main"/"res"/"mipmap-xxhdpi"/"ic_launcher.png", 144, 144)
    iconSrcPath.resizePNG(ctx.build_dir/"app"/"src"/"main"/"res"/"mipmap-xxxhdpi"/"ic_launcher.png", 192, 192)

    let
      srcResources = ctx.projectPath/ctx.config.resourceDir
      dstResources = ctx.build_dir/"app"/"src"/"main"/"assets"
    if srcResources.dirExists:
      ctx.log &"Copying in resources ..."
      createDir(dstResources)
      copyDir(srcResources, dstResources)
    
    ctx.log "Prepare to create Activity ..."
    ctx.activityJavaPath.parentDir.createDir()
  of Build:
    ctx.logStartStep
    doAssert ctx.activityJavaPath.fileExists, "Other plugins failed to create Java Activity file"
    
    ctx.log &"Naming app ..."
    replaceInFile(ctx.build_dir/"app"/"src"/"main"/"res"/"values"/"strings.xml", {
      "<string name=\"app_name\">.*?</string>": &"""<string name="app_name">{ctx.config.name}</string>""",
    }.toTable)

    ctx.log &"Building with gradle in {ctx.build_dir} ..."
    withDir(ctx.build_dir):
      var args = @[findExe"bash", "gradlew"]
      if ctx.releaseBuild:
        args.add "assembleRelease"
        args.add "bundleRelease"
      else:
        args.add "assembleDebug"
        args.add "bundleDebug"
      args.add "--console=plain"
      debug args.join(" ")
      sh(args)
  of Sign:
    ctx.logStartStep
    if not ctx.doSigning:
      ctx.log "Skipping signing."
      return
    let
      keystore_file = ensureEnv("ANDROID_SIGNING_KEYSTORE")
      keyalias = ensureEnv("ANDROID_SIGNING_KEYALIAS")
      keypassword = ensureEnv("ANDROID_SIGNING_PASSWORD")
      signables = ctx.all_signables()
    ctx.log &"Attempting to sign {signables} ..."
    for filename in signables:
      ctx.log &"Signing {filename} ..."
      var cmd = @[
        "jarsigner",
        "-verbose",
        "-sigalg", "SHA256withRSA",
        "-digestalg", "SHA-256",
        "-storepass", keypassword, # XXX: not sure how I feel about this
        "-keystore", keystore_file,
        filename, keyalias,
      ]
      sh cmd
  of Run:
    ctx.logStartStep
    let adb_bin = findExe("adb")
    if adb_bin == "":
      raise newException(CatchableError, "Could not find 'adb'.  Are the Android SDK tools in PATH?")
    
    let android_home = adb_bin.parentDir.parentDir
    ctx.log &"Android SDK path = {android_home}"

    ctx.log "Finding running emulator devices ..."
    let device_list = runningDevices()
    ctx.log &"Running devices: {device_list.repr}"
    if device_list.len == 0:
      ctx.log "No running devices. Let's start one..."
      let emulator_bin = findExe("emulator")
      let possible_avds = possibleDevices()
      ctx.log &"Found {possible_avds.len} possible devices"
      if possible_avds.len == 0:
        raise newException(CatchableError, "No emulators installed. XXX provide instructions to get them installed.")
      let avd = possible_avds[0]
      ctx.log &"Launching {avd} ..."
      
      var p = startProcess(command=emulator_bin,
        args = @["-avd", possible_avds[0], "-no-snapshot-save"], options = {poUsePath})
      # XXX it would maybe be nice to leave this running...
      ctx.log "Waiting for device to boot ..."
      sh("adb", "wait-for-local-device")
    
      while runningDevices().len == 0:
        ctx.log "Still waiting for device to boot..."
        sleep(1000)
      sleep(1000) # There's some amount of race condition between boot and when the apk can be installed

    ctx.log &"Installing apk {ctx.apk_path} ..."
    sh("adb", "install", "-r", "-t", ctx.apk_path)

    ctx.log &"Watching logs ..."
    var logargs = @["logcat"]
    logargs.add(@["-T", "1"])
    if not ctx.verbose:
      logargs.add("-s")
      logargs.add(ctx.config.get(AndroidConfig).java_package_name)
      logargs.add("nim")
    var logp = startProcess(command="adb", args = logargs, options = {poUsePath, poParentStreams})

    let
      fullActivityName = ctx.fullActivityName()
      fullAppName = fullActivityName.split({'.'})[0..^2].join(".") & "/" & fullActivityName
    ctx.log &"Starting app ({fullActivityName}) on device ..."
    ctx.log fullAppName
    sh("adb", "shell", "am", "start", "-a", "android.intent.action.MAIN", "-n", fullAppName)

    discard logp.waitForExit()
  else:
    discard

proc checkDoctor*():seq[DoctorResult] =

  # ANDROID_SDK_ROOT
  result.dr "standard", "ANDROID_SDK_ROOT":
    dr.targetOS = {Android}
    if getEnv("ANDROID_SDK_ROOT", "") == "":
      dr.status = NotWorking
      dr.error = "ANDROID_SDK_ROOT not set"
      dr.fix = "Install the Android SDK then set ANDROID_SDK_ROOT to the path of the Android sdk."

  # ANDROID_HOME
  result.dr "standard", "ANDROID_HOME":
    dr.targetOS = {Android}
    if getEnv("ANDROID_HOME", "") == "":
      dr.status = NotWorking
      dr.error = "ANDROID_HOME not set"
      dr.fix = """Set ANDROID_HOME to the Android SDK location.  This might work:
        
      export ANDROID_HOME="$ANDROID_SDK_ROOT"
      """

  # ANDROID_NDK_HOME
  result.dr "standard", "ANDROID_NDK_HOME":
    dr.targetOS = {Android}
    if getEnv("ANDROID_NDK_HOME", "") == "":
      dr.status = NotWorking
      dr.error = "ANDROID_NDK_HOME not set"
      dr.fix = """Install the Android NDK then set ANDROID_NDK_HOME to the ndk-bundle path. This might work:
      
      export ANDROID_NDK_HOME="${ANDROID_SDK_ROOT}/ndk-bundle"
      """

  # ndk-build
  result.dr "standard", "ndk-build":
    dr.targetOS = {Android}
    if findExe"ndk-build" == "":
      dr.status = NotWorking
      dr.error = "ndk-build not in PATH"
      dr.fix = """Add the Android NDK path to the PATH. This might work:
    
      export PATH="${ANDROID_NDK_HOME}:${PATH}"
      """

  # emulator
  result.dr "standard", "emulator":
    dr.targetOS = {Android}
    if findExe("emulator") == "":
      dr.status = NotWorking
      dr.error = "Could not find 'emulator'"
      dr.fix = """
      export PATH="${ANDROID_SDK_ROOT}/emulator:${PATH}"
      """

  # adb
  result.dr "standard", "sdk-platform-tools":
    dr.targetOS = {Android}
    if findExe("adb") == "":
      dr.status = NotWorking
      dr.error = "Could not find 'adb'"
      dr.fix = """
      export PATH="${ANDROID_SDK_ROOT}/platform-tools:${PATH}"
      """
  
  # devices
  result.dr "standard", "devices":
    dr.targetOS = {Android}
    try:
      let devices = possibleDevices()
      if devices.len == 0:
        dr.status = NotWorking
        dr.error = "No Android emulation devices found"
        dr.fix = "Use Android Studio to install a device. XXX need better instructions"
    except:
      dr.status = NotWorking
      dr.error = "Could not find any emulation devices"
      dr.fix = "Fix emulator first"

  # code signing
  result.dr "standard", "android-signing-keystore":
    dr.targetOS = {Android}
    if getEnv("ANDROID_SIGNING_KEYSTORE") == "":
      dr.status = NotWorking
      dr.error = "No Android signing keystore found"
      dr.fix = """
      Generate with something like (replace 'mycompany' with something related to you):
        
        keytool -genkey -v -keystore "mycompany-android-key.keystore" -alias "mycompany" -keyalg RSA -sigalg SHA1withRSA -keysize 2048 -validity 10000
      
      Then set

        ANDROID_SIGNING_KEYSTORE="mycompany-android-key.keystore"
      """
  result.dr "standard", "android-signing-keyalias":
    dr.targetOS = {Android}
    if getEnv("ANDROID_SIGNING_KEYALIAS") == "":
      dr.status = NotWorking
      dr.error = "No Android signing key alias found"
      dr.fix = """
      Set `ANDROID_SIGNING_KEYALIAS=` to the alias string you provided
      to `-alias` when you ran `keytool`

        ANDROID_SIGNING_KEYALIAS=mycompany
      """
  result.dr "standard", "android-signing-password":
    dr.targetOS = {Android}
    if getEnv("ANDROID_SIGNING_PASSWORD") == "":
      dr.status = NotWorking
      dr.error = "No Android signing key password found"
      dr.fix = """
      Set `ANDROID_SIGNING_PASSWORD=` to the password you chose when you
      ran `keytool`

        ANDROID_SIGNING_PASSWORD=myterriblepassword
      """


