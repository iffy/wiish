import std/json
import std/logging
import std/os
import std/osproc
import std/sequtils
import std/strformat
import std/strutils
import std/tables
import std/times

import regex

import ./common
import wiish/doctor
import wiish/building/config
import wiish/building/buildutil

proc csource_dir*(ctx: ref BuildContext, android_abi: string): string {.inline.}

proc replaceInFile*(filename: string, replacements: Table[string, string]) =
  ## Replace lines in a file with the given replacements
  var guts = filename.readFile()
  for pattern, replacement in replacements:
    guts = guts.replace(re(pattern), replacement)
  filename.writeFile(guts)

proc activityName*(ctx: ref BuildContext): string {.inline.} =
  ctx.config.get(AndroidConfig).java_package_name.split({'.'})[^1] & "Activity"

proc fullActivityName*(ctx: ref BuildContext): string {.inline.} =
  ## Return the java.style.activity.name of an app
  ctx.config.get(AndroidConfig).java_package_name & "." & ctx.activityName()

proc activityJavaPath*(ctx: ref BuildContext): string =
  ## Return the path to the Java Activity .java file
  ctx.build_dir / "app" / "src" / "main" / "java" / ctx.config.get(AndroidConfig).java_package_name.replace(".", "/") / ctx.activityName() & ".java"

proc parseNimBuildDeps(path: string): tuple[cfiles:seq[string], ipaths:seq[string]] =
  ## Parse the .json file generated by nim --compileOnly --genScript
  ## and return the external c files and -I paths
  let depsjson = path.readFile.parseJson
  var
    external_c_files: seq[string]
    external_i_paths: seq[string]
  for item in depsjson["compile"]:
    let src = item[0].getStr()
    external_c_files.add(src)

    let cmd = item[1].getStr()
    # TODO: yes, this is naive and won't work if there are spaces in path names
    let parts = cmd.split(" ")
    for segment in parts:
      if segment.startsWith("-I"):
        let ipath = segment[2..^1].normalizedPath.absolutePath
        if ipath notin external_i_paths:
          external_i_paths.add(ipath)
  return (external_c_files, external_i_paths)

proc nimBuildDepJson(ctx: ref BuildContext, abi: string): string =
  ctx.csource_dir(abi) / ctx.main_nim.extractFilename.changeFileExt(".json")

proc getCFiles*(ctx: ref BuildContext): seq[string] =
  ## Get the list of C files and static libs to be compiled
  ctx.log "Listing c files ..."
  for arch in ctx.config.get(AndroidConfig).archs:
    let srcdir = ctx.csource_dir(arch.abi).normalizedPath
    ctx.log &"Using {srcdir} for c files ..."
    if srcdir.existsDir():
      for item in walkDir(srcdir):
        if item.kind == pcFile and (item.path.endsWith(".c") or item.path.endsWith(".a")):
          ctx.log "  " & item.path.extractFilename()
          result.add("$(TARGET_ARCH_ABI)"/(&"{item.path.extractFilename}"))
    # external c files
    let (cfiles, ipaths) = parseNimBuildDeps(ctx.nimBuildDepJson(arch.abi))
    for cfile in cfiles:
      var f = cfile.normalizedPath
      if f.parentDir.isRelativeTo(srcdir):
        # exclude files already included up above
        continue
      ctx.log "  " & f
      result.add f
    if result.len > 0:
      break

proc getIncludePaths*(ctx: ref BuildContext): seq[string] =
  ## Return the previously-generated
  for arch in ctx.config.get(AndroidConfig).archs:
    let (cfiles, ipaths) = parseNimBuildDeps(ctx.nimBuildDepJson(arch.abi))
    ctx.log &"Found {ipaths.len} -I paths ..."
    result.add ipaths
    if result.len > 0:
      break

proc runningDevices(): seq[string] {.inline.} = 
  ## List all currently running Android devices
  shoutput("adb", "devices").strip.splitLines[1..^1]

proc possibleDevices(): seq[string] =
  ## List all installed android devices
  let emulator_bin = findExe("emulator")
  return shoutput(emulator_bin, "-list-avds").strip.splitLines

proc apk_path(ctx: ref BuildContext): string {.inline.} =
  let searchdir = block:
    if ctx.releaseBuild:
      ctx.build_dir/"app"/"build"/"outputs"/"apk"/"release"
    else:
      ctx.build_dir/"app"/"build"/"outputs"/"apk"/"debug"
  for path in walkDirRec(searchdir):
    if path.endsWith(".apk") and "universal" in path:
      return path

proc all_signables(ctx: ref BuildContext): seq[string] =
  ## Return all things that can be signed
  for path in walkDirRec(ctx.build_dir/"app"/"build"/"outputs"):
    # if path.endsWith(".apk") or path.endsWith(".aab"):
    if path.endsWith(".aab"):
      result.add path

proc csource_dir*(ctx: ref BuildContext, android_abi: string): string {.inline.} =
  ctx.build_dir/"app"/"jni"/"src"/android_abi

proc ensureEnv*(varname: string): string =
  ## Retrieve an environment variable or fail trying
  result = getEnv(varname)
  if result == "":
    raise ValueError.newException(&"Expected a value for environment variable {varname}")

proc androidRunStep*(step: BuildStep, ctx: ref BuildContext) =
  ## Wiish Standard Android build
  case step
  of Setup:
    ctx.logStartStep
    ctx.build_dir = ctx.projectPath / ctx.config.outDir / "android" / "project" / ctx.config.get(AndroidConfig).java_package_name
    ctx.build_dir.parentdir.createDir()
    if ctx.build_dir.dirExists():
      ctx.log "Removing old build dir: ", ctx.build_dir
      ctx.build_dir.removeDir()
    ctx.nim_flags.add ctx.config.nimFlags
    ctx.nim_flags.add "-d:appJavaPackageName=" & ctx.config.get(AndroidConfig).java_package_name
    if ctx.releaseBuild:
      ctx.nim_flags.add "-d:release"
    ctx.log &"archs = {ctx.config.get(AndroidConfig).archs}"
    if ctx.config.get(AndroidConfig).version_code == 0:
      ctx.config.get(AndroidConfig).version_code = getTime().toUnix()
    ctx.log &"version_code = {ctx.config.get(AndroidConfig).version_code}"
  of Compile:
    ctx.logStartStep
    proc buildFor(android_abi:string, cpu:string) =
      let nimcachedir = ctx.csource_dir(android_abi)
      if nimcachedir.dirExists:
        nimcachedir.removeDir()
      var nimFlags:seq[string]
      nimFlags.add(@["nim", "c"])
      nimFlags.add(ctx.nim_flags)
      nimFlags.add(@[
        "--os:android",
        "-d:android",
        "-d:androidNDK",
        &"--cpu:{cpu}",
        "--noMain:on",
        "--gc:orc",
        "--header",
        "--threads:on",
        "--tlsEmulation:off",
        "--hints:off",
        "--compileOnly",
        "--genScript",
        &"-d:appJavaPackageName={ctx.config.get(AndroidConfig).java_package_name}",
        "--nimcache:" & nimcachedir,
        ctx.main_nim,
      ])
      ctx.log nimFlags.join(" ")
      sh(nimFlags)
      
      # copy in dependent c files
      # let json_file = nimcachedir / ctx.main_nim.extractFilename.changeFileExt(".json")
      # ctx.log "Making list of external C files and -I paths ..."
      # var external_c_files: seq[string]
      # var external_i_paths: seq[string]
      # let depsjson = json_file.readFile.parseJson
      # for item in depsjson["compile"]:
      #   let src = item[0].getStr()
      #   external_c_files.add(src)

      #   let cmd = item[1].getStr()
      #   # TODO: yes, this is naive and won't work if there are spaces in path names
      #   let parts = cmd.split(" ")
      #   for segment in parts:
      #     if segment.startsWith("-I"):
      #       let ipath = segment[2..^1].normalizedPath.absolutePath
      #       if ipath notin external_i_paths:
      #         external_i_paths.add(ipath)
      # let extcfiles = nimcachedir / "wiish_external_c_files.txt"
      # ctx.log &"Writing {extcfiles} w/ {external_c_files.len} c files ..."
      # writeFile(extcfiles, external_c_files.join("\n") & "\n")
      # let extipath = nimcachedir / "wiish_external_i_paths.txt"
      # ctx.log &"Writing {extipath} w/ {external_i_paths.len} -I paths ..."
      # writeFile(extipath, external_i_paths.join("\n") & "\n")
      # let
      #   nimbase_dst = ctx.build_dir/"app"/"jni"/"src"/android_abi/"nimbase.h"
      #   nimversion = execCmdEx("nim --version").output.split(" ")[3]
      #   nimminor = nimversion.rsplit(".", 1)[0]
      # ctx.log &"Writing {nimbase_dst} for Nim version {nimminor} ..."
      # let nimbase_h = case nimminor
      #   of "1.0": NIMBASE_1_0_X
      #   of "1.2": NIMBASE_1_2_X
      #   of "1.4": NIMBASE_1_4_x
      #   of "1.6": NIMBASE_1_6_x
      #   else:
      #     raise ValueError.newException("Unsupported Nim version: " & nimversion)
      # nimbase_dst.writeFile(nimbase_h)

    # Android ABIs: https://developer.android.com/ndk/guides/android_mk#taa
    # nim --cpus: https://github.com/nim-lang/Nim/blob/devel/lib/system/platforms.nim#L14
    var abis: seq[string]
    for arch in ctx.config.get(AndroidConfig).archs:
      buildFor(arch.abi, arch.cpu)
      abis.add(arch.abi)
    let abilist = abis.mapIt("'" & it & "'").join(", ")
    replaceInFile(ctx.build_dir/"app"/"build.gradle", {
      "compileSdkVersion.*?\n": &"compileSdkVersion {ctx.config.get(AndroidConfig).target_sdk_version}\n",
      "minSdkVersion.*?\n": &"minSdkVersion {ctx.config.get(AndroidConfig).min_sdk_version}\n",
      "versionCode .*?\n": &"versionCode {ctx.config.get(AndroidConfig).version_code}\n",
      "targetSdkVersion.*?\n": &"targetSdkVersion {ctx.config.get(AndroidConfig).target_sdk_version}\n",
      "\"APP_PLATFORM=.*?\"": &"\"APP_PLATFORM=android-{ctx.config.get(AndroidConfig).min_sdk_version}\"",
      "abiFilters.*?\n": &"abiFilters {abilist}\n",
    }.toTable)
  of PreBuild:
    ctx.logStartStep
    ctx.log &"Creating icons ..."
    var iconSrcPath:string
    if ctx.config.iconPath == "":
      iconSrcPath = stdDatadir/"default.png"
    else:
      iconSrcPath = ctx.projectPath/ctx.config.iconPath
    iconSrcPath.resizePNG(ctx.build_dir/"app"/"src"/"main"/"res"/"mipmap-mdpi"/"ic_launcher.png", 48, 48)
    iconSrcPath.resizePNG(ctx.build_dir/"app"/"src"/"main"/"res"/"mipmap-hdpi"/"ic_launcher.png", 72, 72)
    iconSrcPath.resizePNG(ctx.build_dir/"app"/"src"/"main"/"res"/"mipmap-xhdpi"/"ic_launcher.png", 96, 96)
    iconSrcPath.resizePNG(ctx.build_dir/"app"/"src"/"main"/"res"/"mipmap-xxhdpi"/"ic_launcher.png", 144, 144)
    iconSrcPath.resizePNG(ctx.build_dir/"app"/"src"/"main"/"res"/"mipmap-xxxhdpi"/"ic_launcher.png", 192, 192)

    let
      srcResources = ctx.projectPath/ctx.config.resourceDir
      dstResources = ctx.build_dir/"app"/"src"/"main"/"assets"
    if srcResources.dirExists:
      ctx.log &"Copying in resources ..."
      createDir(dstResources)
      copyDir(srcResources, dstResources)
    
    ctx.log "Prepare to create Activity ..."
    ctx.activityJavaPath.parentDir.createDir()
  of Build:
    ctx.logStartStep
    doAssert ctx.activityJavaPath.fileExists, "Other plugins failed to create Java Activity file"
    
    ctx.log &"Naming app ..."
    replaceInFile(ctx.build_dir/"app"/"src"/"main"/"res"/"values"/"strings.xml", {
      "<string name=\"app_name\">.*?</string>": &"""<string name="app_name">{ctx.config.name}</string>""",
    }.toTable)

    ctx.log &"Building with gradle in {ctx.build_dir} ..."
    withDir(ctx.build_dir):
      var args = @[findExe"bash", "gradlew"]
      if ctx.releaseBuild:
        args.add "assembleRelease"
        args.add "bundleRelease"
      else:
        args.add "assembleDebug"
        args.add "bundleDebug"
      args.add "--console=plain"
      debug args.join(" ")
      sh(args)
  of Sign:
    ctx.logStartStep
    if not ctx.doSigning:
      ctx.log "Skipping signing."
      return
    let
      keystore_file = ensureEnv("ANDROID_SIGNING_KEYSTORE")
      keyalias = ensureEnv("ANDROID_SIGNING_KEYALIAS")
      keypassword = ensureEnv("ANDROID_SIGNING_PASSWORD")
      signables = ctx.all_signables()
    ctx.log &"Attempting to sign {signables} ..."
    for filename in signables:
      ctx.log &"Signing {filename} ..."
      var cmd = @[
        "jarsigner",
        "-verbose",
        "-sigalg", "SHA256withRSA",
        "-digestalg", "SHA-256",
        "-storepass", keypassword, # XXX: not sure how I feel about this
        "-keystore", keystore_file,
        filename, keyalias,
      ]
      sh cmd
  of Run:
    ctx.logStartStep
    let adb_bin = findExe("adb")
    if adb_bin == "":
      raise newException(CatchableError, "Could not find 'adb'.  Are the Android SDK tools in PATH?")
    
    let android_home = adb_bin.parentDir.parentDir
    ctx.log &"Android SDK path = {android_home}"

    ctx.log "Finding running emulator devices ..."
    let device_list = runningDevices()
    ctx.log &"Running devices: {device_list.repr}"
    if device_list.len == 0:
      ctx.log "No running devices. Let's start one..."
      let emulator_bin = findExe("emulator")
      let possible_avds = possibleDevices()
      ctx.log &"Found {possible_avds.len} possible devices"
      if possible_avds.len == 0:
        raise newException(CatchableError, "No emulators installed. XXX provide instructions to get them installed.")
      let avd = possible_avds[0]
      ctx.log &"Launching {avd} ..."
      
      var p = startProcess(command=emulator_bin,
        args = @["-avd", possible_avds[0], "-no-snapshot-save"], options = {poUsePath})
      # XXX it would maybe be nice to leave this running...
      ctx.log "Waiting for device to boot ..."
      sh("adb", "wait-for-local-device")
    
      while runningDevices().len == 0:
        ctx.log "Still waiting for device to boot..."
        sleep(1000)
      sleep(1000) # There's some amount of race condition between boot and when the apk can be installed

    ctx.log &"Installing apk {ctx.apk_path} ..."
    sh("adb", "install", "-r", "-t", ctx.apk_path)

    ctx.log &"Watching logs ..."
    var logargs = @["logcat"]
    logargs.add(@["-T", "1"])
    if not ctx.verbose:
      logargs.add("-s")
      logargs.add(ctx.config.get(AndroidConfig).java_package_name)
      logargs.add("nim")
    var logp = startProcess(command="adb", args = logargs, options = {poUsePath, poParentStreams})

    let
      fullActivityName = ctx.fullActivityName()
      fullAppName = fullActivityName.split({'.'})[0..^2].join(".") & "/" & fullActivityName
    ctx.log &"Starting app ({fullActivityName}) on device ..."
    ctx.log fullAppName
    sh("adb", "shell", "am", "start", "-a", "android.intent.action.MAIN", "-n", fullAppName)

    discard logp.waitForExit()
  else:
    discard

proc doAndroidBuild*(directory:string, config: WiishConfig): string =
  ## Package an Android app
  ## Returns the path to the app

  # From SDL2 source, following:
  # - ./docs/README-android.md
  # - ./build-scripts/androidbuild.sh
  # let
  #   projectDir = directory/config.dst/"android"/"project"/config.get(AndroidConfig).java_package_name
  #   appSrc = directory/config.src
  #   sdlSrc = stdDatadir/"SDL"
  #   webviewSrc = stdDatadir/"android-webview"
  #   # appProject = projectDir/"app"/"jni"/"app"
  #   srcResources = directory/config.resourceDir
  #   dstResources = projectDir/"app"/"src"/"main"/"assets"
  #   # androidNDKPath = getEnvOrFail("ANDROID_NDK", "Set to your local Android NDK path.  Download from https://developer.android.com/ndk/downloads/")
  #   # androidSDKPath = getEnvOrFail("ANDROID_SDK", "Set to your local Android SDK path.  Download from https://developer.android.com/studio/#downloads")

#   if projectDir.dirExists():
#     projectDir.removeDir()

#   if config.windowFormat == SDL:
#     if not projectDir.dirExists():
#       debug &"Copying SDL android project to {projectDir}"
#       createDir(projectDir)
#       copyDirWithPermissions(sdlSrc/"android-project", projectDir)

#       # Copy in SDL source
#       copyDirWithPermissions(sdlSrc/"src", projectDir/"app"/"jni"/"SDL"/"src")
#       copyDirWithPermissions(sdlSrc/"include", projectDir/"app"/"jni"/"SDL"/"include")
#       let android_mk = projectDir/"app"/"jni"/"SDL"/"Android.mk"
#       copyFile(sdlSrc/"Android.mk", android_mk)

#       # build.gradle
#       replaceInFile(projectDir/"app"/"build.gradle", {
#         "org.libsdl.app": config.get(AndroidConfig).java_package_name,
#       }.toTable)

#       # AndroidManifest.xml
#       replaceInFile(projectDir/"app"/"src"/"main"/"AndroidManifest.xml", {
#         "org.libsdl.app": config.get(AndroidConfig).java_package_name,
#       }.toTable)

#   elif config.windowFormat == Webview:
#     if not projectDir.dirExists():
#       debug &"Copying Android template project to {projectDir}"
#       createDir(projectDir)
#       copyDirWithPermissions(webviewSrc, projectDir)

#       # build.gradle
#       replaceInFile(projectDir/"app"/"build.gradle", {
#         "org.wiish.exampleapp": config.get(AndroidConfig).java_package_name,
#       }.toTable)

#       # AndroidManifest.xml
#       replaceInFile(projectDir/"app"/"src"/"main"/"AndroidManifest.xml", {
#         "org.wiish.exampleapp": config.get(AndroidConfig).java_package_name,
#       }.toTable)

#   debug "Compiling Nim portion ..."
#   proc buildFor(android_abi:string, cpu:string) =
#     let nimcachedir = projectDir/"app"/"jni"/"src"/android_abi
#     if nimcachedir.dirExists:
#       nimcachedir.removeDir()
#     var nimFlags:seq[string]
#     nimFlags.add(["nim", "c"])
#     nimFlags.add(config.nimflags)
#     nimFlags.add([
#       "--os:android",
#       "-d:android",
#       "-d:androidNDK",
#       &"--cpu:{cpu}",
#       "--noMain:on",
#       "--gc:orc",
#       "--header",
#       "--threads:on",
#       "--tlsEmulation:off",
#       "--hints:off",
#       "--compileOnly",
#       &"-d:appJavaPackageName={config.get(AndroidConfig).java_package_name}",
#       "--nimcache:" & nimcachedir,
#       appSrc,
#     ])
#     debug nimFlags.join(" ")
#     sh(nimFlags)
    
#     let
#       nimbase_dst = projectDir/"app"/"jni"/"src"/android_abi/"nimbase.h"
#       nimversion = execCmdEx("nim --version").output.split(" ")[3]
#       nimminor = nimversion.rsplit(".", 1)[0]
#     debug &"Writing {nimbase_dst} for Nim version {nimminor} ..."
#     let nimbase_h = case nimminor
#       of "1.0": NIMBASE_1_0_X
#       of "1.2": NIMBASE_1_2_X
#       of "1.4": NIMBASE_1_4_x
#       else:
#         raise ValueError.newException("Unsupported Nim version: " & nimversion)
#     nimbase_dst.writeFile(nimbase_h)

#   # Android ABIs: https://developer.android.com/ndk/guides/android_mk#taa
#   # nim --cpus: https://github.com/nim-lang/Nim/blob/devel/lib/system/platforms.nim#L14
#   buildFor("armeabi-v7a", "arm")
#   buildFor("arm64-v8a", "arm64")
#   buildFor("x86", "i386")
#   buildFor("x86_64", "amd64")

# # # https://developer.android.com/ndk/guides/prebuilts
# #   debug "Create application code Android.mk ..."
# #   writeFile(appProject/"Android.mk", """
# # LOCAL_PATH := $(call my-dir)

# # include $(CLEAR_VARS)
# # LOCAL_MODULE := main
# # LOCAL_SRC_FILES := $(TARGET_ARCH_ABI)/libmain.so
# # include $(PREBUILT_SHARED_LIBRARY)
# # """)

#   debug "Create Activity ..."
#   let
#     activity_name = config.activityName()
#     activity_java_path = projectDir/"app"/"src"/"main"/"java"/config.get(AndroidConfig).java_package_name.replace(".", "/")/activity_name&".java"
#   activity_java_path.parentDir.createDir()
  
#   var cfiles : seq[string]
#   debug "Listing c files ..."
#   for item in walkDir(projectDir/"app"/"jni"/"src"/"x86"):
#     if item.kind == pcFile and item.path.endsWith(".c"):
#       cfiles.add("$(TARGET_ARCH_ABI)"/(&"{item.path.extractFilename}"))
  
#   replaceInFile(projectDir/"app"/"build.gradle", {
#     "abiFilters.*?\n": "abiFilters 'arm64-v8a', 'armeabi-v7a', 'x86', 'x86_64'\n",
#   }.toTable)

#   if config.windowFormat == SDL:
#     #---------------------------------------
#     # SDL
#     #---------------------------------------
#     writeFile(activity_java_path, &"""
# package {config.get(AndroidConfig).java_package_name};

# import org.libsdl.app.SDLActivity;

# public class {activity_name} extends SDLActivity
# {{
# }}
# """)
#     replaceInFile(projectDir/"app"/"src"/"main"/"AndroidManifest.xml", {
#       "SDLActivity": activity_name,
#     }.toTable)
#     writeFile(projectDir/"app"/"jni"/"src"/"Android.mk",
# &"""
# LOCAL_PATH := $(call my-dir)

# include $(CLEAR_VARS)
# LOCAL_MODULE := main
# LOCAL_C_INCLUDES := $(LOCAL_PATH)/../SDL/include
# LOCAL_SRC_FILES := {cfiles.join(" ")}
# LOCAL_SHARED_LIBRARIES := SDL2
# LOCAL_LDLIBS := -lGLESv1_CM -lGLESv2 -llog

# include $(BUILD_SHARED_LIBRARY)
# """)
#   elif config.windowFormat == Webview:
#     #---------------------------------------
#     # Webview
#     #---------------------------------------
#     writeFile(activity_java_path, &"""
# package {config.get(AndroidConfig).java_package_name};

# import org.wiish.exampleapp.WiishActivity;

# public class {activity_name} extends WiishActivity
# {{
# }}
#     """)
#     replaceInFile(projectDir/"app"/"src"/"main"/"AndroidManifest.xml", {
#       "WiishActivity": activity_name,
#     }.toTable)
#     writeFile(projectDir/"app"/"jni"/"src"/"Android.mk",
# &"""
# LOCAL_PATH := $(call my-dir)

# include $(CLEAR_VARS)
# LOCAL_MODULE := main
# LOCAL_SRC_FILES := {cfiles.join(" ")}
# LOCAL_LDLIBS := -llog

# include $(BUILD_SHARED_LIBRARY)
#     """)
  
#   debug &"Naming app ..."
#   replaceInFile(projectDir/"app"/"src"/"main"/"res"/"values"/"strings.xml", {
#     "<string name=\"app_name\">.*?</string>": &"""<string name="app_name">{config.name}</string>""",
#   }.toTable)

#   debug &"Creating icons ..."
#   var iconSrcPath:string
#   if config.icon == "":
#     iconSrcPath = stdDatadir/"default.png"
#   else:
#     iconSrcPath = directory/config.icon
#   iconSrcPath.resizePNG(projectDir/"app"/"src"/"main"/"res"/"mipmap-mdpi"/"ic_launcher.png", 48, 48)
#   iconSrcPath.resizePNG(projectDir/"app"/"src"/"main"/"res"/"mipmap-hdpi"/"ic_launcher.png", 72, 72)
#   iconSrcPath.resizePNG(projectDir/"app"/"src"/"main"/"res"/"mipmap-xhdpi"/"ic_launcher.png", 96, 96)
#   iconSrcPath.resizePNG(projectDir/"app"/"src"/"main"/"res"/"mipmap-xxhdpi"/"ic_launcher.png", 144, 144)
#   iconSrcPath.resizePNG(projectDir/"app"/"src"/"main"/"res"/"mipmap-xxxhdpi"/"ic_launcher.png", 192, 192)

#   if srcResources.dirExists:
#     debug &"Copying in resources ..."
#     createDir(dstResources)
#     copyDir(srcResources, dstResources)

#   debug &"Building with gradle in {projectDir} ..."
#   withDir(projectDir):
#     # TODO: assembleRelease?
#     let args = ["/bin/bash", "gradlew", "assembleDebug", "--console=plain"]
#     debug args.join(" ")
#     sh(args)
  
#   result = projectDir/"app"/"build"/"outputs"/"apk"/"debug"/"app-universal-debug.apk"

# proc doAndroidRun*(directory: string, verbose: bool = false) =
#   ## Run the application in the Android emulator
#   let
#     configPath = directory/"wiish.toml"
#     config = getAndroidConfig(parseConfig(configPath))

#   let adb_bin = findExe("adb")
#   if adb_bin == "":
#     raise newException(CatchableError, "Could not find 'adb'.  Are the Android SDK tools in PATH?")
  
#   let android_home = adb_bin.parentDir.parentDir
#   debug &"Android SDK path = {android_home}"

#   debug "Building app ..."
#   let apkPath = doAndroidBuild(directory, config)

#   debug "Opening emulator ..."
#   let device_list = runningDevices()
#   debug &"devices: {device_list.repr}"
#   if device_list.len == 0:
#     debug "No running devices. Let's start one..."
#     let emulator_bin = findExe("emulator")
#     let possible_avds = possibleDevices()
#     debug &"Found {possible_avds.len} possible devices"
#     if possible_avds.len == 0:
#       raise newException(CatchableError, "No emulators installed. XXX provide instructions to get them installed.")
#     let avd = possible_avds[0]
#     debug &"Launching {avd} ..."
    
#     var p = startProcess(command=emulator_bin,
#       args = @["-avd", possible_avds[0], "-no-snapshot-save"], options = {poUsePath})
#     # XXX it would maybe be nice to leave this running...
#     debug "Waiting for device to boot ..."
#     sh("adb", "wait-for-local-device")
  
#   debug &"Installing apk {apkPath} ..."
#   sh("adb", "install", "-r", "-t", apkPath)

#   debug &"Watching logs ..."
#   var logargs = @["logcat"]
#   logargs.add(@["-T", "1"])
#   if not verbose:
#     logargs.add("-s")
#     logargs.add(config.get(AndroidConfig).java_package_name)
#     logargs.add("nim")
#   var logp = startProcess(command="adb", args = logargs, options = {poUsePath, poParentStreams})

#   let
#     fullActivityName = config.fullActivityName()
#     fullAppName = fullActivityName.split({'.'})[0..^2].join(".") & "/" & fullActivityName
#   debug &"Starting app ({fullActivityName}) on device ..."
#   debug fullAppName
#   sh("adb", "shell", "am", "start", "-a", "android.intent.action.MAIN", "-n", fullAppName)

#   discard logp.waitForExit()


proc checkDoctor*():seq[DoctorResult] =

  # ANDROID_SDK_ROOT
  result.dr "standard", "ANDROID_SDK_ROOT":
    dr.targetOS = {Android}
    if getEnv("ANDROID_SDK_ROOT", "") == "":
      dr.status = NotWorking
      dr.error = "ANDROID_SDK_ROOT not set"
      dr.fix = "Install the Android SDK then set ANDROID_SDK_ROOT to the path of the Android sdk."

  # ANDROID_HOME
  result.dr "standard", "ANDROID_HOME":
    dr.targetOS = {Android}
    if getEnv("ANDROID_HOME", "") == "":
      dr.status = NotWorking
      dr.error = "ANDROID_HOME not set"
      dr.fix = """Set ANDROID_HOME to the Android SDK location.  This might work:
        
      export ANDROID_HOME="$ANDROID_SDK_ROOT"
      """

  # ANDROID_NDK_HOME
  result.dr "standard", "ANDROID_NDK_HOME":
    dr.targetOS = {Android}
    if getEnv("ANDROID_NDK_HOME", "") == "":
      dr.status = NotWorking
      dr.error = "ANDROID_NDK_HOME not set"
      dr.fix = """Install the Android NDK then set ANDROID_NDK_HOME to the ndk-bundle path. This might work:
      
      export ANDROID_NDK_HOME="${ANDROID_SDK_ROOT}/ndk-bundle"
      """

  # ndk-build
  result.dr "standard", "ndk-build":
    dr.targetOS = {Android}
    if findExe"ndk-build" == "":
      dr.status = NotWorking
      dr.error = "ndk-build not in PATH"
      dr.fix = """Add the Android NDK path to the PATH. This might work:
    
      export PATH="${ANDROID_NDK_HOME}:${PATH}"
      """

  # emulator
  result.dr "standard", "emulator":
    dr.targetOS = {Android}
    if findExe("emulator") == "":
      dr.status = NotWorking
      dr.error = "Could not find 'emulator'"
      dr.fix = """
      export PATH="${ANDROID_SDK_ROOT}/emulator:${PATH}"
      """

  # adb
  result.dr "standard", "sdk-platform-tools":
    dr.targetOS = {Android}
    if findExe("adb") == "":
      dr.status = NotWorking
      dr.error = "Could not find 'adb'"
      dr.fix = """
      export PATH="${ANDROID_SDK_ROOT}/platform-tools:${PATH}"
      """
  
  # devices
  result.dr "standard", "devices":
    dr.targetOS = {Android}
    try:
      let devices = possibleDevices()
      if devices.len == 0:
        dr.status = NotWorking
        dr.error = "No Android emulation devices found"
        dr.fix = "Use Android Studio to install a device. XXX need better instructions"
    except:
      dr.status = NotWorking
      dr.error = "Could not find any emulation devices"
      dr.fix = "Fix emulator first"

  # code signing
  result.dr "standard", "android-signing-keystore":
    dr.targetOS = {Android}
    if getEnv("ANDROID_SIGNING_KEYSTORE") == "":
      dr.status = NotWorking
      dr.error = "No Android signing keystore found"
      dr.fix = """
      Generate with something like (replace 'mycompany' with something related to you):
        
        keytool -genkey -v -keystore "mycompany-android-key.keystore" -alias "mycompany" -keyalg RSA -sigalg SHA1withRSA -keysize 2048 -validity 10000
      
      Then set

        ANDROID_SIGNING_KEYSTORE="mycompany-android-key.keystore"
      """
  result.dr "standard", "android-signing-keyalias":
    dr.targetOS = {Android}
    if getEnv("ANDROID_SIGNING_KEYALIAS") == "":
      dr.status = NotWorking
      dr.error = "No Android signing key alias found"
      dr.fix = """
      Set `ANDROID_SIGNING_KEYALIAS=` to the alias string you provided
      to `-alias` when you ran `keytool`

        ANDROID_SIGNING_KEYALIAS=mycompany
      """
  result.dr "standard", "android-signing-password":
    dr.targetOS = {Android}
    if getEnv("ANDROID_SIGNING_PASSWORD") == "":
      dr.status = NotWorking
      dr.error = "No Android signing key password found"
      dr.fix = """
      Set `ANDROID_SIGNING_PASSWORD=` to the password you chose when you
      ran `keytool`

        ANDROID_SIGNING_PASSWORD=myterriblepassword
      """


